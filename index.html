<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tile-it</title>
<link rel="stylesheet" href="styles/theme.css">
<style>
  *{ box-sizing:border-box }
  body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background-color:var(--bg); background-image:var(--grid-bg); color:var(--text); }
  .wrap{ max-width:1200px; margin:0 auto; padding:16px; }
  .title{ display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:12px }
  .row{ display:grid; grid-template-columns: 320px 1fr 320px; gap:16px }
  .col-left, .col-right{ display:flex; flex-direction:column; gap:16px; }
  @media (max-width:980px){ .row{ grid-template-columns:1fr } }
  .card{ background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:14px }
  .btn{ background:var(--accent); color:var(--bg); border:none; padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:600 }
  .btn:disabled{ opacity:0.5; cursor:not-allowed }
  .btn.ghost{ background:transparent; border:1px solid var(--border); color:var(--text) }
  .btn.secondary{ background:var(--panel); border:1px solid var(--border); color:var(--text) }
  input[type="number"], input[type="text"], select { width:100%; padding:8px; border-radius:10px; border:1px solid var(--border); background:var(--bg); color:var(--text) }
  .toolbar{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
  .seg{ display:flex; gap:6px; flex-wrap:wrap }
  .seg button{ padding:8px 10px; border-radius:10px; border:1px solid var(--border); background:var(--bg); color:var(--text); cursor:pointer }
  .seg button.active{ background:var(--accent); color:var(--bg); border-color:var(--accent) }
  .layers{ max-height:520px; overflow:auto; border:1px solid var(--border); border-radius:10px; }
  .layer{ display:grid; grid-template-columns: 24px 24px 1fr 24px 24px; gap:8px; align-items:center; padding:8px 10px; border-bottom:1px solid var(--border); cursor:default; user-select:none; }
  .layer:last-child{ border-bottom:none }
  .layer .thumb{ width:28px; height:28px; border-radius:6px; background:var(--bg); border:1px solid var(--border); display:flex; align-items:center; justify-content:center; overflow:hidden }
  .layer .thumb img{ max-width:100%; max-height:100% }
  .layer .name{ overflow:hidden; text-overflow:ellipsis; white-space:nowrap; font-size:12px }
  .layer .icon{ width:22px; height:22px; display:grid; place-items:center; border:1px solid var(--border); border-radius:6px; background:var(--bg); cursor:pointer }
  .layer.selected{ background:var(--bg); outline:1px solid var(--accent) }
  .layer.locked{ opacity:0.7 }
  .drag-handle{ cursor:grab; }
  #canvasWrap{ position:relative; width:100%; overflow:hidden; border-radius:12px; }
  #tile{ background-color:transparent; border:1px solid var(--border); border-radius:12px; display:block; }
  .hint{ color:var(--muted); font-size:12px }
  #tileCard { display: flex; flex-direction: column; }
  #tileCard > #canvasWrap { flex-grow: 1; display: grid; place-items: center; }
  .overlay{ position:fixed; inset:0; background:rgba(0,0,0,0.8); display:none; align-items:center; justify-content:center; z-index:1000 }
  .overlay-content{ background:var(--panel); border:1px solid var(--border); color:var(--text); padding:24px; border-radius:12px; max-width:400px; }
  #patternPreview{ width:100%; height:160px; border:1px solid var(--border); border-radius:10px; background-color:var(--bg); background-repeat:repeat; margin-top:8px }
</style>

<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#10b981">
<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js');
  }
</script>

</head>
<body>
  <div class="wrap">
    <div class="title">
      <h1 style="margin:0">Tile-it</h1>
      <div class="toolbar">
        <button id="undoBtn" class="btn secondary" disabled>Undo</button>
        <button id="redoBtn" class="btn secondary" disabled>Redo</button>
        <label class="toolbar" style="gap:6px"><input id="bgToggle" type="checkbox" checked /> Background on</label>
        <input id="bgColor" type="color" value="#0f1220" />
        <label class="toolbar" style="gap:6px"><input id="themeToggle" type="checkbox" /> Light Mode</label>
        <button id="helpBtn" class="btn secondary" title="Help">?</button>
      </div>
    </div>

    <div class="row">
      <div class="col-left">
        <div class="card">
          <h2 style="margin:0 0 8px 0">Import Images</h2>
          <input type="file" id="fileInput" accept="image/*" multiple />
          <div class="hint" style="margin-top:6px">Doubleâ€‘click a thumbnail to add it as a new layer.</div>
          <div id="assetThumbs" style="display:flex; gap:8px; flex-wrap:wrap; margin-top:8px"></div>
        </div>

        <div class="card">
          <h2 style="margin:0 0 8px 0">Layers</h2>
          <div id="layers" class="layers"></div>
          <div class="toolbar" style="margin-top:8px; flex-wrap:wrap">
            <button id="duplicateBtn" class="btn ghost">Duplicate</button>
            <button id="deleteBtn" class="btn secondary">Delete</button>
            <button id="flipVBtn" class="btn ghost" title="Flip Vertical (Y)">Flip V</button>
            <button id="flipHBtn" class="btn ghost" title="Flip Horizontal (X)">Flip H</button>
            <button id="downBtn" class="btn ghost">Send Backward</button>
            <button id="upBtn" class="btn ghost">Bring Forward</button>
          </div>
        </div>
      </div>

      <div class="card" id="tileCard">
        <h2 style="margin:0 0 8px 0">Tile</h2>
        <div id="canvasWrap">
          <canvas id="tile" class="transparent-bg" width="1000" height="1000"></canvas>
        </div>
      </div>

      <div class="col-right">
        <div class="card">
          <h2 style="margin:0 0 8px 0">Export</h2>
          <div class="toolbar" style="gap:8px">
            <label class="hint">Size</label>
            <select id="exportSize">
              <option value="512">512</option>
              <option value="1000" selected>1000</option>
              <option value="1024">1024</option>
              <option value="2048">2048</option>
              <option value="4096">4096</option>
            </select>
            <label class="hint">or custom</label>
            <input id="exportCustom" type="number" min="64" max="8192" step="1" placeholder="custom px" style="width:120px" />
          </div>
          <div class="toolbar" style="margin-top:8px; gap:8px">
            <label class="hint">File name</label>
            <input id="fileName" type="text" placeholder="tile" value="tile" style="width:160px" />
            <button id="exportBtn" class="btn">Export PNG</button>
            <button id="repeatExportBtn" class="btn secondary">Repeat & Export</button>
          </div>
          <div id="estTime" class="hint" style="margin-top:6px">Estimated time: instant</div>
          <div id="patternPreview"></div>
        </div>

        <div class="card">
            <h2 style="margin:0 0 8px 0">Tools</h2>
            <button id="saveProjectBtn" class="btn secondary" style="margin-top: 8px; width: 100%;">Save Project</button>
            <button id="loadProjectBtn" class="btn ghost" style="margin-top: 8px; width: 100%;">Load Project</button>
            <input type="file" id="loadProjectInput" accept="application/json" style="display:none" />
        </div>
      </div>
    </div>
  </div>

  <div id="helpOverlay" class="overlay">
    <div class="overlay-content">
      <h2 style="margin-top:0">Getting Started</h2>
      <p>Import images using the <strong>Import Images</strong> panel.</p>
      <p>Manipulate and arrange your images in the <strong>Layers</strong> panel.</p>
      <p>When you're ready, use the <strong>Export</strong> panel to save your tile.</p>
      <button id="closeHelpBtn" class="btn secondary" style="margin-top:12px">Close</button>
    </div>
  </div>

  <script>
  // ====== State ======
  const assets = [];
  let layers = [];
  let selectedIds = [];
  let currentWrap = {ox:0, oy:0};
  const history = [];
  const redoStack = [];
  const HISTORY_LIMIT = 100;

  // ====== DOM ======
  const fileInput = document.getElementById('fileInput');
  const assetThumbs = document.getElementById('assetThumbs');
  const layerList = document.getElementById('layers');
  const canvasWrap = document.getElementById('canvasWrap');
  const canvas = document.getElementById('tile');
  const ctx = canvas.getContext('2d');
  const bgToggle = document.getElementById('bgToggle');
  const bgColorInput = document.getElementById('bgColor');
  const exportSizeSel = document.getElementById('exportSize');
  const exportCustom = document.getElementById('exportCustom');
  const exportBtn = document.getElementById('exportBtn');
  const repeatExportBtn = document.getElementById('repeatExportBtn');
  const fileNameInput = document.getElementById('fileName');
  const estTime = document.getElementById('estTime');
  const patternPreview = document.getElementById('patternPreview');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const flipHBtn = document.getElementById('flipHBtn');
  const flipVBtn = document.getElementById('flipVBtn');
  const duplicateBtn = document.getElementById('duplicateBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  const upBtn = document.getElementById('upBtn');
  const downBtn = document.getElementById('downBtn');
  const saveProjectBtn = document.getElementById('saveProjectBtn');
  const loadProjectBtn = document.getElementById('loadProjectBtn');
  const loadProjectInput = document.getElementById('loadProjectInput');
  const helpBtn = document.getElementById('helpBtn');
  const helpOverlay = document.getElementById('helpOverlay');
  const closeHelpBtn = document.getElementById('closeHelpBtn');

  canvas.classList.toggle('transparent-bg', !bgToggle.checked);

  const PROJECT_KEY = 'tileProject';

  // ====== Utils ======
  const uid = (()=>{ let i=1; return ()=> i++; })();
  function getAsset(assetId){ return assets.find(a=>a.id===assetId); }
  function getLayer(id){ return layers.find(l=>l.id===id); }
  function setSelected(ids){ selectedIds = Array.isArray(ids) ? ids : [ids]; currentWrap={ox:0,oy:0}; renderLayers(); draw(); }
  function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }
  function snapshot(){ return { layers: deepClone(layers), selectedIds: deepClone(selectedIds), canvasSize:{w:canvas.width,h:canvas.height}, bg:{show:bgToggle.checked, color:bgColorInput.value} }; }
  function applySnapshot(s){ canvas.width = s.canvasSize.w; canvas.height = s.canvasSize.h; bgToggle.checked = !!s.bg.show; bgColorInput.value = s.bg.color; canvas.classList.toggle('transparent-bg', !bgToggle.checked); layers = deepClone(s.layers); selectedIds = s.selectedIds || []; currentWrap={ox:0,oy:0}; updateZoom(); renderLayers(); draw(); updateUndoUI(); }

  function getGridConfig(){ const g = localStorage.getItem('gridConfig'); return g ? JSON.parse(g) : null; }
  function projectSnapshot(){ const data = { tile: snapshot(), grid: getGridConfig() }; localStorage.setItem(PROJECT_KEY, JSON.stringify(data)); return data; }
  function applyProject(p){ if(p.tile) applySnapshot(p.tile); else applySnapshot(p); if(p.grid) localStorage.setItem('gridConfig', JSON.stringify(p.grid)); }
  function pushHistory(){ history.push(snapshot()); if(history.length>HISTORY_LIMIT) history.shift(); redoStack.length = 0; updateUndoUI(); }
  function updateUndoUI(){ undoBtn.disabled = history.length<=1; redoBtn.disabled = redoStack.length===0; }
  function undo(){ if(history.length<=1) return; const curr = history.pop(); redoStack.push(curr); const prev = history[history.length-1]; applySnapshot(prev); }
  function redo(){ if(!redoStack.length) return; const s = redoStack.pop(); history.push(s); applySnapshot(s); }
  function drawWrappedImage(img, x, y, w, h, rad, flipH=false, flipV=false){ const W = canvas.width, H = canvas.height; const pts = [[0,0],[-W,0],[W,0],[0,-H],[0,H],[-W,-H],[W,-H],[-W,H],[W,H]]; for(const [ox,oy] of pts){ ctx.save(); ctx.translate(x+ox,y+oy); ctx.rotate(rad); ctx.scale(flipH?-1:1, flipV?-1:1); ctx.drawImage(img,-w/2,-h/2,w,h); ctx.restore(); } }
  function pointToLocal(x,y,layer,wrap={ox:0,oy:0}){ const dx=(x-(layer.x+wrap.ox)), dy=(y-(layer.y+wrap.oy)); const rad=-layer.rot*Math.PI/180; const c=Math.cos(rad), s=Math.sin(rad); return { x: dx*c - dy*s, y: dx*s + dy*c }; }
  function wrappedOffsets(){ const W=canvas.width,H=canvas.height; return [{ox:0,oy:0},{ox:-W,oy:0},{ox:W,oy:0},{ox:0,oy:-H},{ox:0,oy:H},{ox:-W,oy:-H},{ox:W,oy:-H},{ox:-W,oy:H},{ox:W,oy:H}]; }
  function hitTestWrapped(x,y){ for(let i=layers.length-1;i>=0;i--){ const L=layers[i]; if(!L.visible||L.locked) continue; const A=getAsset(L.assetId); if(!A) continue; const halfW=A.w*L.scale/2, halfH=A.h*L.scale/2; for(const off of wrappedOffsets()){ const p=pointToLocal(x,y,L,off); if(p.x>=-halfW && p.x<=halfW && p.y>=-halfH && p.y<=halfH){ return {layer:L, wrap:off}; } } } return null; }
  function handleAtWrapped(layer, x, y){ const A=getAsset(layer.assetId); if(!A) return null; const w=A.w*layer.scale, h=A.h*layer.scale; for(const off of wrappedOffsets()){ const p=pointToLocal(x,y,layer,off); const pts=[[-w/2,-h/2],[0,-h/2],[w/2,-h/2],[w/2,0],[w/2,h/2],[0,h/2],[-w/2,h/2],[-w/2,0]]; for(let i=0;i<pts.length;i++){ const dx=p.x-pts[i][0], dy=p.y-pts[i][1]; if(Math.abs(dx)<=10 && Math.abs(dy)<=10) return {which:i, wrap:off}; } if(Math.hypot(p.x-0,p.y-(-h/2-28))<=14) return {which:'rot', wrap:off}; } return null; }
  function drawSelection(layer){ const A=getAsset(layer.assetId); if(!A) return; const w=A.w*layer.scale, h=A.h*layer.scale; const wrap=currentWrap; ctx.save(); ctx.translate(layer.x+wrap.ox,layer.y+wrap.oy); ctx.rotate(layer.rot*Math.PI/180); ctx.strokeStyle= '#10b981'; ctx.setLineDash([6,4]); ctx.lineWidth=2; ctx.strokeRect(-w/2,-h/2,w,h); ctx.setLineDash([]); const hs=10; ctx.fillStyle='#fff'; ctx.strokeStyle='#000'; const pts=[[-w/2,-h/2],[0,-h/2],[w/2,-h/2],[w/2,0],[w/2,h/2],[0,h/2],[-w/2,h/2],[-w/2,0]]; for(const p of pts){ ctx.beginPath(); ctx.rect(p[0]-hs/2,p[1]-hs/2,hs,hs); ctx.fill(); ctx.stroke(); } ctx.beginPath(); ctx.arc(0,-h/2-24,7,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.restore(); }
  function clear(){ if(bgToggle.checked){ ctx.fillStyle=bgColorInput.value; ctx.fillRect(0,0,canvas.width,canvas.height); } else { ctx.clearRect(0,0,canvas.width,canvas.height); } }
  function draw(){ clear(); for(const L of layers){ if(!L.visible) continue; const A=getAsset(L.assetId); if(!A) continue; const w=A.w*L.scale, h=A.h*L.scale; drawWrappedImage(A.img, L.x, L.y, w, h, L.rot*Math.PI/180, !!L.flipH, !!L.flipV); } const primary = selectedIds.length ? getLayer(selectedIds[selectedIds.length-1]) : null; if(primary) drawSelection(primary); updatePatternPreview(); }
  function renderAssets(){ assetThumbs.innerHTML=''; for(const a of assets){ const d=document.createElement('div'); d.style.width='64px'; d.style.height='64px'; d.style.border='1px solid var(--border)'; d.style.borderRadius='8px'; d.style.background='#0b1020'; d.style.display='grid'; d.style.placeItems='center'; d.style.overflow='hidden'; d.title='Doubleâ€‘click to add as layer'; const im=document.createElement('img'); im.src=a.img.src; im.style.maxWidth='100%'; im.style.maxHeight='100%'; d.appendChild(im); d.addEventListener('dblclick', ()=> addLayerFromAsset(a.id)); assetThumbs.appendChild(d); } }
  function renderLayers(){ layerList.innerHTML=''; layers.forEach((L)=>{ const row=document.createElement('div'); row.className='layer' + (selectedIds.includes(L.id)?' selected':'') + (L.locked?' locked':''); row.dataset.id=L.id; const drag=document.createElement('div'); drag.className='icon drag-handle'; drag.textContent='â‰¡'; const eye=document.createElement('div'); eye.className='icon'; eye.textContent= L.visible?'ðŸ‘':'ðŸš«'; const th=document.createElement('div'); th.className='thumb'; const im=document.createElement('img'); im.src=getAsset(L.assetId)?.img.src||''; th.appendChild(im); const name=document.createElement('div'); name.className='name'; name.textContent=L.name + (L.flipH?' [â‡‹]':'') + (L.flipV?' [â‡…]':''); const lock=document.createElement('div'); lock.className='icon'; lock.textContent=L.locked?'ðŸ”’':'ðŸ”“'; row.appendChild(drag); row.appendChild(eye); row.appendChild(th); row.appendChild(name); row.appendChild(lock); row.addEventListener('click', (e)=>{ if(!e.ctrlKey && !e.metaKey) setSelected([L.id]); else { const s=new Set(selectedIds); if(s.has(L.id)) s.delete(L.id); else s.add(L.id); setSelected([...s]); } }); name.addEventListener('dblclick', ()=>{ const nn=prompt('Layer name', L.name||''); if(nn!=null){ L.name=nn; renderLayers(); }}); eye.addEventListener('click', (e)=>{ e.stopPropagation(); L.visible=!L.visible; renderLayers(); draw(); pushHistory(); }); lock.addEventListener('click', (e)=>{ e.stopPropagation(); L.locked=!L.locked; renderLayers(); pushHistory(); }); row.draggable=true; row.addEventListener('dragstart', (ev)=>{ ev.dataTransfer.setData('text/plain', String(L.id)); }); row.addEventListener('dragover', (ev)=> ev.preventDefault()); row.addEventListener('drop', (ev)=>{ ev.preventDefault(); const fromId=parseInt(ev.dataTransfer.getData('text/plain')); const toId=L.id; reorderLayer(fromId,toId); }); layerList.appendChild(row); }); }
  function addLayerFromAsset(assetId){ const A=getAsset(assetId); if(!A) return; const id=uid(); const off=layers.length*12; const L={ id, assetId, name:A.name||('Layer '+id), x: canvas.width/2+off, y: canvas.height/2+off, scale: Math.min(1, canvas.width/(A.w*1.5)), rot: 0, visible:true, locked:false, flipH:false, flipV:false }; layers.push(L); setSelected([id]); renderLayers(); draw(); pushHistory(); }
  function reorderLayer(fromId,toId){ const fromIdx=layers.findIndex(l=>l.id===fromId); const toIdx=layers.findIndex(l=>l.id===toId); if(fromIdx<0||toIdx<0||fromIdx===toIdx) return; const [it]=layers.splice(fromIdx,1); layers.splice(toIdx,0,it); renderLayers(); draw(); pushHistory(); }
  function duplicateSelected(){ if(!selectedIds.length) return; const id=selectedIds[selectedIds.length-1]; const L=getLayer(id); if(!L) return; const copy={...L, id:uid(), x:L.x+20, y:L.y+20, name:L.name+' copy'}; layers.splice(layers.indexOf(L)+1,0,copy); setSelected([copy.id]); renderLayers(); draw(); pushHistory(); }
  function deleteSelected(){ if(!selectedIds.length) return; layers=layers.filter(l=>!selectedIds.includes(l.id)); selectedIds=[]; renderLayers(); draw(); pushHistory(); }
  function bringForward(){ if(!selectedIds.length) return; const id=selectedIds[selectedIds.length-1]; const i=layers.findIndex(l=>l.id===id); if(i<0||i===layers.length-1) return; const [it]=layers.splice(i,1); layers.splice(i+1,0,it); renderLayers(); draw(); pushHistory(); }
  function sendBackward(){ if(!selectedIds.length) return; const id=selectedIds[selectedIds.length-1]; const i=layers.findIndex(l=>l.id===id); if(i<=0) return; const [it]=layers.splice(i,1); layers.splice(i-1,0,it); renderLayers(); draw(); pushHistory(); }
  let mode='idle'; let start={x:0,y:0}; let startLayer=null; let activeHandle=null; const keysDown = new Set(); let changedDuringDrag=false;
  function toCanvas(e){ const r=canvas.getBoundingClientRect(); return { x:(e.clientX-r.left)*canvas.width/r.width, y:(e.clientY-r.top)*canvas.height/r.height }; }
  function wrapCoord(x,y){ const W=canvas.width,H=canvas.height; while(x<0) x+=W; while(y<0) y+=H; x%=W; y%=H; return {x,y}; }
  canvas.addEventListener('mousedown', (e)=>{ const p=toCanvas(e); changedDuringDrag=false; const top = selectedIds.length ? getLayer(selectedIds[selectedIds.length-1]) : null; if(top){ const h=handleAtWrapped(top,p.x,p.y); if(h){ const wantRotate = (h.which==='rot') || e.altKey || keysDown.has('r'); mode = wantRotate ? 'rotate' : 'scale'; activeHandle=h.which; start=p; startLayer={...top}; currentWrap=h.wrap; return; } } const hit = hitTestWrapped(p.x,p.y); if(hit){ if(hit.layer.locked) return; setSelected([hit.layer.id]); mode = keysDown.has('r') ? 'rotate' : 'move'; start=p; startLayer={...hit.layer}; currentWrap=hit.wrap; } else { setSelected([]); mode='idle'; currentWrap={ox:0,oy:0}; } });
  window.addEventListener('mousemove', (e)=>{ if(mode==='idle'||!selectedIds.length) return; const L=getLayer(selectedIds[selectedIds.length-1]); if(!L) return; const p=toCanvas(e); if(mode==='move'){ const dx=p.x-start.x, dy=p.y-start.y; const wrapped=wrapCoord(startLayer.x+dx,startLayer.y+dy); L.x=wrapped.x; L.y=wrapped.y; changedDuringDrag=true; draw(); } else if(mode==='rotate'){ const cx=L.x+currentWrap.ox, cy=L.y+currentWrap.oy; const a1=Math.atan2(start.y-cy,start.x-cx); const a2=Math.atan2(p.y-cy,p.x-cx); let deg=(startLayer.rot + (a2-a1)*180/Math.PI); if(e.shiftKey){ deg=Math.round(deg/15)*15; } L.rot=deg; changedDuringDrag=true; draw(); } else if(mode==='scale'){ const A=getAsset(L.assetId); if(!A) return; if(keysDown.has('r')){ mode='rotate'; return; } const localStart=pointToLocal(start.x,start.y,L,currentWrap); const localNow=pointToLocal(p.x,p.y,L,currentWrap); const dist0=Math.hypot(localStart.x, localStart.y); const dist1=Math.hypot(localNow.x, localNow.y); let s = (dist1 / Math.max(1e-6, dist0)) * startLayer.scale; L.scale = Math.max(0.01, s); changedDuringDrag=true; draw(); } });
  window.addEventListener('mouseup', ()=>{ if(changedDuringDrag){ pushHistory(); } mode='idle'; activeHandle=null; });
  window.addEventListener('keydown', (e)=>{ const k=e.key.toLowerCase(); keysDown.add(k); if((e.ctrlKey||e.metaKey) && k==='z' && !e.shiftKey){ e.preventDefault(); undo(); return; } if((e.ctrlKey||e.metaKey) && k==='z' && e.shiftKey){ e.preventDefault(); redo(); return; } const top = selectedIds.length ? getLayer(selectedIds[selectedIds.length-1]) : null; if(e.key==='Delete' || e.key==='Backspace'){ deleteSelected(); return; } if((e.ctrlKey||e.metaKey) && k==='d'){ e.preventDefault(); duplicateSelected(); return; } if(top && !e.ctrlKey && !e.metaKey){ if(k==='x'){ top.flipH = !top.flipH; draw(); renderLayers(); pushHistory(); return; } if(k==='y'){ top.flipV = !top.flipV; draw(); renderLayers(); pushHistory(); return; } } if(!top) return; const step = e.shiftKey ? 10 : 1; if(['arrowleft','arrowright','arrowup','arrowdown'].includes(k)){ e.preventDefault(); if(k==='arrowleft') top.x=wrapCoord(top.x-step, top.y).x; if(k==='arrowright') top.x=wrapCoord(top.x+step, top.y).x; if(k==='arrowup') top.y=wrapCoord(top.x, top.y-step).y; if(k==='arrowdown') top.y=wrapCoord(top.x, top.y+step).y; draw(); pushHistory(); } if(k==='l'){ top.locked=!top.locked; renderLayers(); pushHistory(); } if(k==='h'){ top.visible=!top.visible; renderLayers(); draw(); pushHistory(); } if(e.key===']'){ bringForward(); } if(e.key==='['){ sendBackward(); } });
  window.addEventListener('keyup', (e)=>{ keysDown.delete(e.key.toLowerCase()); });
  duplicateBtn.addEventListener('click', duplicateSelected);
  deleteBtn.addEventListener('click', deleteSelected);
  upBtn.addEventListener('click', bringForward);
  downBtn.addEventListener('click', sendBackward);
  undoBtn.addEventListener('click', undo);
  redoBtn.addEventListener('click', redo);
  flipHBtn.addEventListener('click', ()=>{ const top = selectedIds.length ? getLayer(selectedIds[selectedIds.length-1]) : null; if(!top) return; top.flipH=!top.flipH; renderLayers(); draw(); pushHistory(); });
  flipVBtn.addEventListener('click', ()=>{ const top = selectedIds.length ? getLayer(selectedIds[selectedIds.length-1]) : null; if(!top) return; top.flipV=!top.flipV; renderLayers(); draw(); pushHistory(); });
  bgToggle.addEventListener('change', ()=>{ canvas.classList.toggle('transparent-bg', !bgToggle.checked); draw(); pushHistory(); });
  bgColorInput.addEventListener('change', ()=>{ draw(); pushHistory(); });
  bgColorInput.addEventListener('input', ()=>{ draw(); });
  function updateZoom(){ const z = 0.45; const cssW = Math.max(280, Math.round(canvas.width * z)); canvas.style.width = cssW + 'px'; canvas.style.height = 'auto'; }
  function estimateTime(px){ const n = layers.length; const work = n * (px*px); if(work < 2e8) return 'instant'; if(work < 6e8) return '~0.5â€“1s'; if(work < 1.2e9) return '~1â€“2s'; return 'a few seconds'; }
  function getExportSize(){ const custom = parseInt(exportCustom.value); return (custom && custom>0) ? custom : parseInt(exportSizeSel.value); }
  exportSizeSel.addEventListener('change', ()=>{ estTime.textContent = 'Estimated time: ' + estimateTime(getExportSize()); updatePatternPreview(); });
  exportCustom.addEventListener('input', ()=>{ estTime.textContent = 'Estimated time: ' + estimateTime(getExportSize()); updatePatternPreview(); });
  function drawTileToCanvas(size){ const off=document.createElement('canvas'); off.width=size; off.height=size; const octx=off.getContext('2d'); if(bgToggle.checked){ octx.fillStyle=bgColorInput.value; octx.fillRect(0,0,size,size); } const sx=size/canvas.width, sy=size/canvas.height; for(const L of layers){ if(!L.visible) continue; const A=getAsset(L.assetId); if(!A) continue; const w=A.w*L.scale*sx, h=A.h*L.scale*sy; const x=L.x*sx, y=L.y*sy; const rad=L.rot*Math.PI/180; const pts=[[0,0],[-size,0],[size,0],[0,-size],[0,size],[-size,-size],[size,-size],[-size,size],[size,size]]; for(const [ox,oy] of pts){ octx.save(); octx.translate(x+ox,y+oy); octx.rotate(rad); octx.scale(L.flipH?-1:1, L.flipV?-1:1); octx.drawImage(A.img,-w/2,-h/2,w,h); octx.restore(); } } return off; }
  function updatePatternPreview(){ const size=Math.min(128, getExportSize()); const off=drawTileToCanvas(size); patternPreview.style.backgroundImage=`url(${off.toDataURL('image/png')})`; patternPreview.style.backgroundSize=`${size}px ${size}px`; }
  exportBtn.addEventListener('click', ()=>{ if(!layers.length){ alert('Add at least one layer.'); return; } const size = getExportSize() || 1000; const off=drawTileToCanvas(size); const a=document.createElement('a'); const base=(fileNameInput.value||'tile').replace(/[^a-z0-9_\-]+/gi,'_'); a.href=off.toDataURL('image/png'); a.download=`${base}_${size}${bgToggle.checked?'':'_transparent'}.png`; a.click(); });
  repeatExportBtn.addEventListener('click', ()=>{ if(!layers.length){ alert('Add at least one layer.'); return; } const size=getExportSize()||1000; const reps=parseInt(prompt('Repeat count per side? (3 for 3x3)','3'),10); if(!reps||reps<1) return; const format=(prompt('Export format? (png/svg)','png')||'png').toLowerCase(); const baseCanvas=drawTileToCanvas(size); const baseName=(fileNameInput.value||'tile').replace(/[^a-z0-9_\-]+/gi,'_'); if(format==='svg'){ const total=size*reps; const imgData=baseCanvas.toDataURL('image/png'); let svg=`<svg xmlns="http://www.w3.org/2000/svg" width="${total}" height="${total}" viewBox="0 0 ${total} ${total}">`; for(let r=0;r<reps;r++){ for(let c=0;c<reps;c++){ svg+=`<image x="${c*size}" y="${r*size}" width="${size}" height="${size}" href="${imgData}" />`; }} svg+='</svg>'; const blob=new Blob([svg],{type:'image/svg+xml'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`${baseName}_repeat_${reps}.svg`; a.click(); URL.revokeObjectURL(url); } else { const total=size*reps; const grid=document.createElement('canvas'); grid.width=total; grid.height=total; const gctx=grid.getContext('2d'); for(let r=0;r<reps;r++){ for(let c=0;c<reps;c++){ gctx.drawImage(baseCanvas,c*size,r*size); }} const a=document.createElement('a'); a.href=grid.toDataURL('image/png'); a.download=`${baseName}_repeat_${reps}.png`; a.click(); } });
  fileInput.addEventListener('change', async (e)=>{ const files=Array.from(e.target.files||[]); if(!files.length) return; for(const f of files){ const url=URL.createObjectURL(f); const img=new Image(); img.crossOrigin='anonymous'; img.src=url; await (img.decode?img.decode():new Promise(res=>{ img.onload=res; })); const id=uid(); assets.push({ id, img, w: img.naturalWidth||img.width, h: img.naturalHeight||img.height, name:f.name }); } renderAssets(); const cols=Math.ceil(Math.sqrt(files.length)); const rows=Math.ceil(files.length/cols); let i=0; const tileW=canvas.width, tileH=canvas.height; for(const a of assets.slice(-files.length)){ const cx = ((i%cols)+0.5)*(tileW/cols); const cy = (Math.floor(i/cols)+0.5)*(tileH/rows); const id=uid(); const s=Math.min(1, (tileW/cols)/(a.w*0.9)); layers.push({ id, assetId:a.id, name:a.name, x:cx, y:cy, scale:s, rot:0, visible:true, locked:false, flipH:false, flipV:false }); i++; } setSelected(layers.length ? [layers[layers.length-1].id] : []); renderLayers(); draw(); estTime.textContent = 'Estimated time: ' + estimateTime(getExportSize()); pushHistory(); });
  const savedProject = localStorage.getItem(PROJECT_KEY);
  if (savedProject) {
    try {
      applyProject(JSON.parse(savedProject));
      pushHistory();
    } catch (e) {
      console.error('Failed to restore project', e);
      updateZoom(); renderLayers(); draw(); pushHistory();
    }
  } else {
    updateZoom(); renderLayers(); draw(); pushHistory();
  }
</script>
<script>
  const themeToggle = document.getElementById('themeToggle');
  const body = document.body;
  const savedTheme = localStorage.getItem('theme');
  if (savedTheme === 'light') {
    body.classList.add('light-mode');
    themeToggle.checked = true;
  }
  themeToggle.addEventListener('change', () => {
    if (themeToggle.checked) {
      body.classList.add('light-mode');
      localStorage.setItem('theme', 'light');
    } else {
      body.classList.remove('light-mode');
      localStorage.setItem('theme', 'dark');
    }
  });
  // Repeat Grid integration removed

  saveProjectBtn.addEventListener('click', () => {
    const data = projectSnapshot();
    const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
    const a = document.createElement('a');
    const base = (fileNameInput.value||'tile').replace(/[^a-z0-9_\-]+/gi,'_');
    a.href = URL.createObjectURL(blob);
    a.download = `${base}.json`;
    a.click();
    URL.revokeObjectURL(a.href);
  });

  loadProjectBtn.addEventListener('click', ()=> loadProjectInput.click());
  loadProjectInput.addEventListener('change', (e)=>{
    const file = e.target.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = ()=>{
      try{
        const data = JSON.parse(reader.result);
        applyProject(data);
        pushHistory();
      }catch(err){
        alert('Invalid project file');
      }
    };
    reader.readAsText(file);
  });

  helpBtn.addEventListener('click', () => {
    helpOverlay.style.display = 'flex';
  });
  closeHelpBtn.addEventListener('click', () => {
    helpOverlay.style.display = 'none';
  });
  helpOverlay.addEventListener('click', (e) => {
    if (e.target === helpOverlay) helpOverlay.style.display = 'none';
  });
</script>
</body>
</html>
